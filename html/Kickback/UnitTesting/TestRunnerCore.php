<?php
declare(strict_types=1);

namespace Kickback\UnitTesting;

use \Kickback\UnitTesting\AssertException;
use \Kickback\UnitTesting\AssertFailureException;
use \Kickback\UnitTesting\AssertParseException;

use \SyncMutex;

// Future directions:
// * Module that:
//     * Scans all source code in a project
//     * Generates a dependency tree of files (using `use` statements, `require_once`, etc).
//     * Traverses the dependency tree with a TestRunner
//     * Looks for functions+methods starting with `unittest` in their name, and having a single "TestRunnerCore" (or "TestRunner" or whatever) parameter
//     * Calls those methods on leaf-most files first, working its way towards the root-most files
// * Parallelization for above project-tester
// * Allow unittest sections to be declared as PHP heredoc strings, so that we don't
//     have to pollute our unittests with `eval` and we don't have to stringize all of our expressions!
// * Test leveling/grouping/dependencies/checkpointing, so that we can keep running tests after a failure (until we hit a test (or test group/level/stage/checkpoint) that depends on a failed test (or test group/level/stage/checkpoint)).
// * Extra level of breakdown for things like `assert((foo === bar) || (baz === qux));`
// * Proper stacktraces
// * assert_throws(...)
//

class TestRunnerCore
{
    private static ?\SyncMutex $id_mutex_;

    private static function id_mutex() : \SyncMutex
    {
        if ( !isset(self::$id_mutex_) ) {
            self::$id_mutex_ = new \SyncMutex(get_class() . ":: id_mutex");
        }
        return self::$id_mutex_;
    }

    // The ID number that identifies this TestRunnerCore instance within the
    // $GLOBALS array. Used to retrieve TestRunnerCore instances from code
    // that is executed within the caller's context (and within an `eval` expression).
    public int $global_id;

    public function __construct()
    {
        // Any test runner instance must end up in the $GLOBALS array, because
        // this is how we can retrieve our test runner instance from within
        // generated code that is executed in the caller's context.
        //
        // Because there is a possible race condition between when we acquire
        // a new ID and when we add ourselves to the $GLOBALS array, we must
        // synchronize this transaction using a SyncMutex object (so that
        // two different threads don't end up creating two TestRunnerCore
        // objects with the same $global_id by acquiring the ID at the
        // exact same time before either is added to the $GLOBALS array).
        $id = 0;
        $key = "";
        self::id_mutex()->lock();
        while(true)
        {
            $id = mt_rand();
            $key = self::key($id);
            if ( !array_key_exists($key, $GLOBALS) ) {
                break; // Done!
            }
        }
        $GLOBALS[$key] = $this;
        $this->global_id = $id;
        self::id_mutex()->unlock();
    }

    private static function key(int $id) : string
    {
        return "\Kickback\UnitTesting\TestRunnerCore::" . dechex($id);
    }

    /**
    * Do not call this directly.
    *
    * There should be no need to call this from code that is both outside of
    * this class AND not generated by this class.
    *
    * This is only declared `public` so that automatically generated
    * code can call this method from within `eval(...)` statements in the
    * caller's code.
    */
    public static function get_test_runner_instance_from_global_id(int $id) : TestRunnerCore
    {
        $key = self::key($id);
        if ( !array_key_exists($key, $GLOBALS) ) {
            $classname = get_class();
            throw new \OutOfBoundsException(
                "Attempted to retrieve a `$classname` from \$GLOBALS['$key'], ".
                "but that key does not exist in \$GLOBALS.");
        }

        $instance = $GLOBALS[$key];
        if ( !($instance instanceof TestRunnerCore) ) {
            // TODO: This should create an error in the error log. It shouldn't happen!
            $expected = get_class();
            $got = get_class($instance);
            throw new \UnexpectedValueException(
                "\$GLOBALS['$key'] should return an instance of `$expected`, ".
                "but instead it was `$got`. This is an internal error. ".
                "It suggests that there is a bug in one of the aforementioned classes.");
        }

        if  ( $instance->global_id !== $id ) {
            $classname = get_class();
            $inst_id = $instance->global_id;
            throw new \LogicException(
                "$classname at \$GLOBALS['$key'] has a `global_id` member equal to `$inst_id`, ".
                "but the key suggests an ID of `$id`. They should ALWAYS match, but these do not. ".
                "This is an internal error. It is definitely a bug.");
        }

        return $instance;
    }

    /**
    * Do not call this directly. Call `assert` instead.
    *
    * This is only declared `public` so that `assert`'s automatically generated
    * code can call this method from within `eval(...)` statements in the
    * caller's code.
    */
    public function assert_impl_nullary(
        string $expr,
        string $subst,
        mixed  $val
        ) : void
    {
        if ($val)
            return;

        $str_val = var_export($val);
        throw new AssertFailureException("ERROR: Assertion failed: ($expr) -> ($subst) -> ($str_val) -> false");
    }

    public function assert_eval_failed_unary(
        \Throwable $exc,
        string $expr,
        string $subst
        ) : never
    {
        if ( $exc instanceof AssertException ) {
            // Normal assertion failure.
            // It's already the way it should be.
            // Pass it through.
            throw $exc;
        }
        else {
            // Assertion failure because one of the expressions in the
            // assertion statement threw an exception before we could
            // even test for equality/inequality/truthiness/etc.
            $exc_name = get_class($exc);
            $exc_message = $exc->getMessage();
            throw new AssertFailureException(
                "ERROR: Assertion failed with thrown exception: ".
                "($expr) -> ($subst) -> $exc_name(\"$exc_message\")");
        }
    }

    private static function evaluate_binary_result(
        string $op,
        string $expr_lhs,  string $expr_rhs,
        string $subst_lhs, string $subst_rhs,
        mixed $val_lhs,    mixed $val_rhs
        ) : bool
    {
        switch($op)
        {
            // These are ranked roughly in order of likelyhood, with the most
            // likely branches appearing first.
            // Secondary to that, we try to group them functionally.

            // Equality and Inequality group
            case "===": return ($val_lhs === $val_rhs);
            case "!==": return ($val_lhs !== $val_rhs);

            // Other comparison operators
            case "<":   return ($val_lhs <   $val_rhs);
            case "<=":  return ($val_lhs <=  $val_rhs);
            case ">":   return ($val_lhs >   $val_rhs);
            case ">=":  return ($val_lhs >=  $val_rhs);

            case "==":  return ($val_lhs ==  $val_rhs);
            case "!=":  return ($val_lhs !=  $val_rhs);
            case "<>":  return ($val_lhs <>  $val_rhs);

            // Boolean (binary) logic operators
            case "&&":  return ($val_lhs &&  $val_rhs);
            case "||":  return ($val_lhs ||  $val_rhs);

            // Non-boolean binary operators
            case "+":   return (bool)($val_lhs  +  $val_rhs);
            case "-":   return (bool)($val_lhs  -  $val_rhs);
            case "&":   return (bool)($val_lhs  &  $val_rhs);
            case "|":   return (bool)($val_lhs  |  $val_rhs);
            case "^":   return (bool)($val_lhs  ^  $val_rhs);
            case "<<":  return (bool)($val_lhs <<  $val_rhs);
            case ">>":  return (bool)($val_lhs >>  $val_rhs);
            case "%":   return (bool)($val_lhs  %  $val_rhs);
            case "*":   return (bool)($val_lhs  *  $val_rhs);
            case "/":   return (bool)($val_lhs  /  $val_rhs);
            case ".":   return (bool)($val_lhs  .  $val_rhs);
            case "??":  return (bool)($val_lhs ??  $val_rhs);
            case "**":  return (bool)($val_lhs **  $val_rhs);

            // Op-assignment operators
            case "+=":  return (bool)($val_lhs +=  $val_rhs);
            case "-=":  return (bool)($val_lhs -=  $val_rhs);
            case "&=":  return (bool)($val_lhs &=  $val_rhs);
            case "|=":  return (bool)($val_lhs |=  $val_rhs);
            case "^=":  return (bool)($val_lhs ^=  $val_rhs);
            case "%=":  return (bool)($val_lhs %=  $val_rhs);
            case "*=":  return (bool)($val_lhs *=  $val_rhs);
            case "/=":  return (bool)($val_lhs /=  $val_rhs);
            case ".=":  return (bool)($val_lhs .=  $val_rhs);
            case "<<=": return (bool)($val_lhs <<= $val_rhs);
            case ">>=": return (bool)($val_lhs >>= $val_rhs);
            case "??=": return (bool)($val_lhs ??= $val_rhs);
            case "**=": return (bool)($val_lhs **= $val_rhs);

            // The rare spaceship operator
            case "<=>": return (bool)($val_lhs <=> $val_rhs);

            // Things that require string processing to _normalize_ the $op string
            // are handled in a separate switch-case statement.
            default: break;
        }

        // Things that require string processing to _normalize_ the $op string.
        // (These are the absolute last, because they would be the most
        // expensive to check for. It's (probably) worth it to avoid this
        // check as hard as possible, even if these happen to come up
        // a little bit more often than some of the above operators.)
        $op = strtoupper($op); // Replace things like "and", "AnD", "aND", etc all with "AND".
        $op = preg_replace('/\s+/', '', $op); // Replace "? :" with "?:" (Elvis operator)
        switch($op)
        {
            case "?:":  return (bool)($val_lhs ?: $val_rhs);
            case "AND": return ($val_lhs AND $val_rhs);
            case "OR":  return ($val_lhs OR  $val_rhs);
            case "XOR": return ($val_lhs XOR $val_rhs);
            default: break;
        }

        throw new AssertParseException("ERROR: Unknown or unimplemented operator \"$op\" in assertion of (($expr_lhs) $op ($expr_rhs)).");
    }

    private function assert_impl_binary(
        string $op,        bool   $result,
        string $expr_lhs,  string $expr_rhs,
        string $subst_lhs, string $subst_rhs,
        mixed  $val_lhs,   mixed  $val_rhs
        ) : void
    {
        // If the result is truthy, then the assertion has passed, and we have
        // nothing left to do. We leave early in that case.
        if($result) {
            return;
        }

        // But if the result was falsey, then the assertion has failed,
        // and we have to stringize the lhs+rhs values, generate error message(s),
        // and throw an exception.
        $str_lhs = var_export($val_lhs);
        $str_rhs = var_export($val_rhs);

        // TODO: Use debug_backtrace() to get the correct backtrace;
        // ex: https://stackoverflow.com/questions/37109821/give-a-function-the-line-variable-without-needing-to-declare-it
        throw new AssertFailureException(
            "ERROR: Assertion failed: ".
            "(($expr_lhs) $op ($expr_rhs)) -> (($subst_lhs) $op ($subst_rhs)) -> ($str_lhs $op $str_rhs) -> false");
    }

    /**
    * Do not call this directly.
    *
    * Instead, call one of these:
    * * `TestRunner->assert(...)`
    * * `TestRunnerCore->assert_(eq,ne,lt,gt,lte,gte)(...)`
    * * `TestRunnerCore->assert_binary(...)`
    *
    * This is only declared `public` so that `assert`'s automatically generated
    * code can call this method from within `eval(...)` statements in the
    * caller's code.
    */
    public function assert_impl_binary_any(
        string $op,
        string $expr_lhs,  string $expr_rhs,
        string $subst_lhs, string $subst_rhs,
        mixed  $val_lhs,   mixed  $val_rhs
        ) : void
    {
        $result = self::evaluate_binary_result($op, $expr_lhs, $expr_rhs, $subst_lhs, $subst_rhs, $val_lhs, $val_rhs);
        $this->assert_impl_binary($op, $result, $expr_lhs, $expr_rhs, $subst_lhs, $subst_rhs, $val_lhs, $val_rhs);
    }

    // Optimization: avoid calling `self::evaluate_binary_result` for common things
    // like "===", "!==", "<=", ">=", etc.

    /**
    * Do not call this directly.
    * @see assert_impl_binary_any
    */
    public function assert_impl_binary_eq(
        string $op,
        string $expr_lhs,  string $expr_rhs,
        string $subst_lhs, string $subst_rhs,
        mixed  $val_lhs,   mixed  $val_rhs
        ) : void
    {
        $this->assert_impl_binary($op, ($val_lhs === $val_rhs), $expr_lhs, $expr_rhs, $subst_lhs, $subst_rhs, $val_lhs, $val_rhs);
    }

    /**
    * Do not call this directly.
    * @see assert_impl_binary_any
    */
    public function assert_impl_binary_ne(
        string $op,
        string $expr_lhs,  string $expr_rhs,
        string $subst_lhs, string $subst_rhs,
        mixed  $val_lhs,   mixed  $val_rhs
        ) : void
    {
        $this->assert_impl_binary($op, ($val_lhs !== $val_rhs), $expr_lhs, $expr_rhs, $subst_lhs, $subst_rhs, $val_lhs, $val_rhs);
    }

    /**
    * Do not call this directly.
    * @see assert_impl_binary_any
    */
    public function assert_impl_binary_lt(
        string $op,
        string $expr_lhs,  string $expr_rhs,
        string $subst_lhs, string $subst_rhs,
        mixed  $val_lhs,   mixed  $val_rhs
        ) : void
    {
        $this->assert_impl_binary($op, ($val_lhs < $val_rhs), $expr_lhs, $expr_rhs, $subst_lhs, $subst_rhs, $val_lhs, $val_rhs);
    }

    /**
    * Do not call this directly.
    * @see assert_impl_binary_any
    */
    public function assert_impl_binary_gt(
        string $op,
        string $expr_lhs,  string $expr_rhs,
        string $subst_lhs, string $subst_rhs,
        mixed  $val_lhs,   mixed  $val_rhs
        ) : void
    {
        $this->assert_impl_binary($op, ($val_lhs > $val_rhs), $expr_lhs, $expr_rhs, $subst_lhs, $subst_rhs, $val_lhs, $val_rhs);
    }

    /**
    * Do not call this directly.
    * @see assert_impl_binary_any
    */
    public function assert_impl_binary_lte(
        string $op,
        string $expr_lhs,  string $expr_rhs,
        string $subst_lhs, string $subst_rhs,
        mixed  $val_lhs,   mixed  $val_rhs
        ) : void
    {
        $this->assert_impl_binary($op, ($val_lhs <= $val_rhs), $expr_lhs, $expr_rhs, $subst_lhs, $subst_rhs, $val_lhs, $val_rhs);
    }

    /**
    * Do not call this directly.
    * @see assert_impl_binary_any
    */
    public function assert_impl_binary_gte(
        string $op,
        string $expr_lhs,  string $expr_rhs,
        string $subst_lhs, string $subst_rhs,
        mixed  $val_lhs,   mixed  $val_rhs
        ) : void
    {
        $this->assert_impl_binary($op, ($val_lhs >= $val_rhs), $expr_lhs, $expr_rhs, $subst_lhs, $subst_rhs, $val_lhs, $val_rhs);
    }

    // This is similar to `assert_impl`, but does not take the "value" or "val_*"
    // arguments, which allows it to be called without attempting to evaluate
    // the expression(s) first. This is important if attempting to evaluate
    // the expression(s) resulted in an exception being thrown (and we aren't
    // in an "expect_exception"-type assertion).
    public function assert_eval_failed_binary(
        \Throwable $exc,
        string $op,
        string $expr_lhs,  string $expr_rhs,
        string $subst_lhs, string $subst_rhs,
        ) : never
    {
        if ( $exc instanceof AssertException ) {
            // Normal assertion failure.
            // It's already the way it should be.
            // Pass it through.
            throw $exc;
        }
        else {
            // Assertion failure because one of the expressions in the
            // assertion statement threw an exception before we could
            // even test for equality/inequality/truthiness/etc.
            $exc_name = get_class($exc);
            $exc_message = $exc->getMessage();
            throw new AssertFailureException(
                "ERROR: Assertion failed with thrown exception: ".
                "(($expr_lhs) === ($expr_rhs)) -> (($subst_lhs) === ($subst_rhs)) -> $exc_name(\"$exc_message\")");
        }
    }

    public function assert_true(string $expr) : string
    {
        // Escape quotes to create the $esc_* variable, which is similar to $expr_*
        // except that it can be placed into strings that will be eval()'d.
        // This is NOT a security measure, so do not assume that untrusted strings
        // can be passed into this function (an important caveat, as much as that
        // will probably never happen in this context).
        $esc_expr = addslashes($expr);

        // Generate the minimum amount of inline code that can pass the assert
        // evaluation into other functions to complete the assertion evaluation.
        // This step is necessary for capturing strings that represent the
        // expression before it's evaluated, both with and without PHP variable
        // substitutions having been performed.
        $id = $this->global_id;
        $assert_code =
        "try {\n".
        "   TestRunnerCore::get_test_runner_instance_from_global_id($id)->\n".
        "       assert_impl_unary('$esc_expr',\"$esc_expr\",($esc_expr));\n".
        "} catch (\Throwable \$exc) {\n".
        "   TestRunnerCore::get_test_runner_instance_from_global_id($id)->\n".
        "       assert_eval_failed_unary(\$exc,'$esc_expr',\"$esc_expr\");\n".
        "}\n";
        /*
        echo "<!--\n";
        echo "assert_code generated:\n";
        echo $assert_code."\n";
        echo "-->\n";
        */
        return $assert_code;
    }

    public function assert_binary(string $expr_lhs, string $op, string $impl_suffix, string $expr_rhs) : string
    {
        // Escape quotes to create the $esc_* variables, which are similar to $expr_*
        // except that they can be placed into strings that will be eval()'d.
        // This is NOT a security measure, so do not assume that untrusted strings
        // can be passed into this function (an important caveat, as much as that
        // will probably never happen in this context).
        $esc_lhs = addslashes($expr_lhs);
        $esc_rhs = addslashes($expr_rhs);

        // Generate the minimum amount of inline code that can pass the assert
        // evaluation into other functions to complete the assertion evaluation.
        // This step is necessary for capturing strings that represent the
        // expression before it's evaluated, both with and without PHP variable
        // substitutions having been performed.
        $id = $this->global_id;
        $assert_code =
        "use \Kickback\UnitTesting\TestRunnerCore;\n".
        "try {\n".
        "   TestRunnerCore::get_test_runner_instance_from_global_id($id)->\n".
        "       assert_impl_binary_$impl_suffix('$op','$esc_lhs','$esc_rhs',\"$esc_lhs\",\"$esc_rhs\",($expr_lhs),($expr_rhs));\n".
        "} catch (\Throwable \$exc) {\n".
        "   TestRunnerCore::get_test_runner_instance_from_global_id($id)->\n".
        "       assert_eval_failed_binary(\$exc,'$op','$esc_lhs','$esc_rhs',\"$esc_lhs\",\"$esc_rhs\");\n".
        "}\n";

        echo "<!--\n";
        echo "assert_code generated:\n";
        echo $assert_code."\n";
        echo "-->\n";

        return $assert_code;
    }

    public function assert_eq(string $expr_lhs, string $expr_rhs) : string
    {
        return $this->assert_binary($expr_lhs, "===", "eq", $expr_rhs);
    }

    public function assert_ne(string $expr_lhs, string $expr_rhs) : string
    {
        return $this->assert_binary($expr_lhs, "!==", "ne", $expr_rhs);
    }

    public function assert_neq(string $expr_lhs, string $expr_rhs) : string
    {
        return $this->assert_ne($expr_lhs, $expr_rhs);
    }

    public function assert_lt(string $expr_lhs, string $expr_rhs) : string
    {
        return $this->assert_binary($expr_lhs, "<", "lt", $expr_rhs);
    }

    public function assert_gt(string $expr_lhs, string $expr_rhs) : string
    {
        return $this->assert_binary($expr_lhs, ">", "gt", $expr_rhs);
    }

    public function assert_lte(string $expr_lhs, string $expr_rhs) : string
    {
        return $this->assert_binary($expr_lhs, "<=", "lte", $expr_rhs);
    }

    public function assert_le(string $expr_lhs, string $expr_rhs) : string
    {
        return $this->assert_lte($expr_lhs, $expr_rhs);
    }

    public function assert_gte(string $expr_lhs, string $expr_rhs) : string
    {
        return $this->assert_binary($expr_lhs, ">=", "gte", $expr_rhs);
    }

    public function assert_ge(string $expr_lhs, string $expr_rhs) : string
    {
        return $this->assert_gte($expr_lhs, $expr_rhs);
    }

    private function map_pass_fail(
        string $assert_test_php_code,
        string $on_pass_php_expr,
        string $on_fail_php_expr
    ) : string
    {
        // The `return` statements in this are intended to return the given
        // expressions from an enclosing `eval` statement, because the
        // `return` statement is how code within an `eval` statement
        // can be evaluated into a value.
        $assert_code =
        "use \Kickback\UnitTesting\TestRunnerCore;\n".
        "try {\n".
        "   $assert_test_php_code\n".
        "   return ($on_pass_php_expr);\n".
        "} catch (AssertFailureException \$exc) {\n".
        "   return ($on_fail_php_expr);\n".
        "}\n";
        return $assert_code;
    }

    public function passes(string $assert_test_php_code) : string
    {
        return self::map_pass_fail($assert_test_php_code, "true", "false");
    }

    public function fails(string $assert_test_php_code) : string
    {
        return self::map_pass_fail($assert_test_php_code, "false", "true");
    }

    public static function unittest_pass_fail(TestRunnerCore $runner) : void
    {
        $runner->note("Running `\Kickback\UnitTesting\TestRunnerCore::unittest_pass_fail(...)`\n");
        assert(eval($runner->passes($runner->assert_true("true"))));
        assert(eval($runner->passes($runner->assert_eq("1","1"))));
        assert(eval($runner->fails($runner->assert_true("false"))));
        assert(eval($runner->fails($runner->assert_eq("1","2"))));
        $runner->note("  ... passed.\n\n");
    }

    /** Not implemented yet. Sorry. */
    public function assert_throws(string $expr) : string
    {
        return "TODO";
    }

    public static function unittest_throw_assertion(TestRunnerCore $runner) : void
    {
        // TODO
    }

    /**
    * Notes that something happened during unittesting.
    *
    * Such notes can provide additional context for unittests, but they
    * should not be shown in the toplevel of test reports.
    *
    * They can be used to emit informational messages (ex: test function entry,
    * test set passing, etc) whenever a project tester is not available
    * to automatically generate such messages.
    *
    * Future directions: We might not even need a project tester to generate
    * entry/exit messages. That can probably be done using stacktrace info
    * obtained from within tests themselves.
    *
    * This function may be removed if it's few use-case(s) are replaced and
    * it is not in use.
    */
    public function note(string $msg) : void
    {
        // This implementation is quite wrong. But w/e, I just need a future-proof
        // way to bang shit out to the terminal.
        echo $msg;
    }
}

?>
